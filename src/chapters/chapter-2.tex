\chapter{Studi Literatur}

\section{Graf}

Graf adalah struktur diskrit yang terdiri atas simpul dan sisi yang menghubungkan simpul-simpul tersebut. Graf $G$ dapat didefinisikan sebagai sebuah \textit{tuple} yang 
terdiri atas himpunan simpul $V(G)$, himpunan sisi $E(G)$, dan himpunan relasi yang menghubungkan antara tepat dua buah simpul dan tepat sebuah sisi. Titik ujung dari suatu sisi 
adalah dua buah simpul yang terhubung pada sisi tersebut. Cincin adalah sisi yang kedua simpul di ujungnya sama. Graf disebut sederhana jika tidak memiliki lebih 
dari satu sisi yang menghubungkan pasangan simpul berbeda yang sama dan tidak memiliki cincin. Graf berbobot adalah graf yang setiap sisi-sisinya memiliki bobot atau nilai.

Graf berarah adalah graf yang setiap sisi-sisinya dikaitkan dengan suatu arah. Sisi pada graf berarah 
dapat di representasikan dengan $e (u, v)$ yang mana sisi $e$ memiliki arah dan menghubungkan 
simpul $u$ dan simpul $v$ serta arah dari sisi tersebut adalah dari $u$ ke $v$. Dengan menggunakan 
sisi tersebut dari simpul $u$ dapat menuju simpul $v$, namun tidak sebaliknya. Graf yang setiap sisi-sisinya 
tidak memiliki arah disebut dengan graf tak berarah.


\section{Jalur}

Jalur dapat didefinisikan sebagai berikut. Misalkan $n$ merupakan bilangan bulat tak negatif dan $G$ merupakan suatu graf. Sebuah jalur dengan 
panjang $n$ dari simpul $u$ ke simpul $v$ adalah rangkaian yang tersusun atas $n$ buah sisi $e_{1}, e_{2}, ..., e_{n}$ yang mana untuk setiap $1 \leq i \leq n$, $e_{i}$ merupakan sisi 
di $G$ dan sisi $e_{i}$ menghubungkan simpul $v_{i-1}$ dengan simpul $v_{i}$ serta $x_{0} = u$ dan $x_{n} = v$. Singkatnya, jalur adalah rangkaian dari sisi-sisi yang dimulai dari 
suatu simpul dan bergerak dari simpul ke simpul yang terhubung dengan sisi pada graf. Suatu jalur yang dimulai dan diakhiri pada simpul yang sama disebut 
dengan sirkuit, yang mana $v_{0} = v_{n}$ dan minimal melewati sebuah sisi. Suatu jalur disebut sederhana jika sisi yang dilewati jalur tersebut tidak berulang.

Panjang sebuah jalur pada graf tak berbobot adalah jumlah dari sisi-sisi yang dilewati. Panjang dari suatu jalur pada graf berbobot adalah jumlah bobot dari sisi yang dilewati.

\section{Persoalan Jalur Terpendek}

Jalur terpendek dari simpul $u$ ke simpul $v$ adalah jalur yang dimulai dari simpul $u$ dan diakhiri pada simpul $v$ yang memiliki panjang minimum. 
Persoalan jalur terpendek dapat dibagi menjadi 4 variasi, yaitu persoalan jalur terpendek dari simpul $u$ ke simpul $v$, persoalan jalur terpendek yang 
dimulai dari suatu simpul, jalur terpendek untuk setiap pasangan simpul pada graf, dan jalur terpendek yang berakhir pada suatu simpul. Jalur 
terpendek memiliki suatu sifat, yaitu sub-jalur dari suatu jalur terpendek adalah sebuah jalur terpendek. Agar dapat menyimpan jalur terpendek, 
akan digunakan $P(V)$ yang mana untuk tiap $p_{i}$ pada $P(V)$ merupakan pendahulu pada jalur terpendek yang diakhiri di simpul $i$, sehingga untuk mendapatkan 
jalur terpendek yang diakhiri pada simpul ke $u$, dapat dilakukan dengan mencari pendahulu-pendahulu dari simpul tersebut.

\medskip
\lstinputlisting[style=customc]{codes/get-path.txt}

Salah satu permasalahan yang dihadapi dalam melakukan pencarian jalur terpendek adalah ketika terdapat \textit{negative cycle} yang dapat dicapai dari 
simpul awal. \textit{Negative cycle} adalah sirkuit yang memiliki panjang yang negatif. Ketika terdapat sirkuit yang dapat dicapai dari $s$, maka terdapat 
tak hingga jalur yang dapat dibentuk. Jika sirkuit tersebut memiliki panjang yang negatif, dapat dibuktikan bahwa tidak ada jalur terpendek 
yang dimulai dari simpul $s$.

Pada suatu jalur terpendek, mustahil terdapat sirkuit dengan  panjang positif. Misalkan $p = [v_{0}, v_{1}, v_{2}, v_{3}, ..., v_{n}]$ adalah jalur terpendek, 
$c = [v_{i}, v_{i+1}, ..., v_{j-1}, v_{j}]$ adalah sirkuit dengan panjang positif yang terdapat pada $p$, $L(x)$ adalah panjang dari jalur $x$, dan 
$p’ = [v_{0}, v_{1}, ..., v_{i}, v_{j+1}, …, v_{n}]$ adalah jalur $p$ tanpa sirkuit $c$. Jalur $p’$ memiliki panjang $L(p’)$ dan 
$L(p’) = L(p) - L(c) < L(p)$. Panjang jalur $p’$ lebih kecil dari pada panjang jalur $p$, sehingga $p$ tidak mungkin menjadi jalur terpendek.

Pada bahasan subbab dibawah ini, akan digunakan teknik relaxation. Teknik ini menyimpan $D(V)$ sebagai batas atas jarak terpendek dari simpul $s$, 
yang mana di adalah batas atas jarak terpendek dari simpul $s$ ke simpul $i$. Proses relaxing pada sisi $(u, v)$ terdiri atas mengecek apakah estimasi 
jalur terpendek menuju $v$ dapat di perkecil dan mengubah estimasi panjang jalur terpendek. Selain itu, juga akan dipakai fungsi \textit{init-single-source} 
yang merupakan fungsi untuk melakukan inisialisasi pada nilai $P(V)$ dan $D(V)$ serta fungsi relax yang akan menerapkan teknik \textit{relaxation} pada sisi $(u,v)$.

\medskip
\lstinputlisting[style=customc, mathescape=true]{codes/init-single-source.txt}

\medskip
\lstinputlisting[style=customc]{codes/relax.txt}

Dalam menentukan jalur terpendek maupun panjang jalur terpendek, terdapat beberapa algoritma-algoritma seperti berikut.

    \subsection{Algoritma Bellman-Ford}
        Algoritma Bellman-Ford menyelesaikan persoalan jalur terpendek yang dimulai dari suatu simpul dengan menggunakan pendekatan pemrograman dinamis. 
        Algoritma Bellman-Ford juga dapat menangani kasus \textit{negative cycle}. Diberikan 
        graf $G = (V, E, W)$ dengan simpul awal jalur adalah $s$, algoritma Bellman-Ford mengembalikan \textit{boolean true} jika tidak terdapat \textit{negative cycle} dalam 
        jalur terpendek dan algoritma ini akan menghasilkan jalur terpendek yang berasal dari simpul $s$. Algoritma ini melakukan \textit{}{relaxation} secara terus-menerus 
        terhadap sisi-sisi pada graf, sehingga memperkecil nilai estimasi panjang jalur terpendek $D(V)$ hingga mencapai panjang jalur terpendek yang sebenarnya. 
        Berikut adalah \textit{pseudocode} dari algoritma Bellman-Ford.

        \medskip
        \lstinputlisting[style=customc]{codes/bellman-ford.txt}

        Kompleksitas waktu dari algoritma Bellman-Ford adalah $O(VE)$. Algoritma Bellman-Ford dapat digunakan untuk mencari jalur terpendek setiap pasangan simpul pada 
        graf, dengan memanggil fungsi Bellman-Ford untuk setiap simpul pada graf.  Dalam hal tersebut kompleksitas waktunya adalah $O(VVE)$.

    \subsection{Algoritma Dijkstra}
        Algoritma Dijkstra menyelesaikan persoalan jalur terpendek yang dimulai dari suatu simpul melalui pendekatan greedy. Diberikan graf berarah dan berbobot $G = (V, E, W)$, 
        yang mana setiap sisi memiliki bobot yang merupakan bilangan tak negatif dan simpul $s$ yang merupakan simpul awal. Algoritma Dijkstra menyimpan himpunan simpul $U$ yang 
        mana untuk tiap simpul pada $U$, sudah ditentukan jalur terpendek dari $s$. Algoritma ini berulang kali mengambil sebuah simpul $a$ pada $V - U$ yang mempunyai jarak terpendek 
        yang telah diestimasi lalu menambahkan $a$ ke himpunan $U$. Setelah itu, melakukan relaxation kepada semua sisi yang keluar dari $a$. 
        Berikut adalah \textit{pseudocode} dari algoritma Dijkstra.

        \medskip
        \lstinputlisting[style=customc, mathescape=true]{codes/dijkstra.txt}

        Kompleksitas waktu dari algoritma Dijkstra adalah $O(V^{2} + E)$. Ketika menggunakan struktur data seperti \textit{self-balancing binary search tree} 
        atau \textit{heap} pada $U$ dan $V$, kompleksitas waktu dari algoritma ini dapat mencapai $O((V + E) * \log V)$.

        Algoritma Dijkstra dapat digunakan untuk mencari jalur terpendek setiap pasangan simpul pada graf, dengan memanggil fungsi Dijkstra untuk setiap simpul pada graf. 
        Dalam hal tersebut kompleksitas waktunya adalah $O(V*(V + E)* \log V)$.

    \subsection{Algoritma Floyd-Warshall}
        Algoritma Floyd-Warshall menggunakan pendekatan pemrograman dinamis dalam menemukan jalur terpendek untuk setiap pasangan simpul pada graf berarah dan 
        berbobot $G = (V, E, W)$. Dalam menentukan jalur terpendek $(u,v)$, algoritma ini memperhatikan simpul intermediate, yaitu pada jalur 
        $p = [v_{1}, v_{2}, v_{3}, ..., v_{n}]$, simpul intermediate adalah simpul yang bukan $v_{1}$ ataupun $v_{n}$. Algoritma ini bergantung pada observasi berikut. 
        Misalkan $V = {1, 2, 3, ..., n}$ adalah simpul-simpul pada graf, $R = {1, 2, ..., k}$ adalah himpunan bagian dari $V$, untuk jalur terpendek dari 
        setiap pasangan $(i, j)$ pada $V$ yang memiliki simpul intermediate dari $R$, dan $p$ adalah jalur terpendek dari pasangan-pasangan simpul tersebut. 
        Hubungan dari $k$ dengan $p$ adalah sebagai berikut.

        \begin{enumerate}
            \item Jika $k$ bukan simpul intermediate dari $p$, maka simpul-simpul intermediate dari $p$ adalah $R’ = {1, 2, ..., k-1}$.
            \item Jika $k$ adalah simpul intermediate dari $p$, jalur terpendek $p$ dapat didekomposisi menjadi jalur terpendek $p^{(1)}$ dari $i$ ke $k$ 
            dan jalur terpendek $p^{(2)}$ dari $k$ ke $j$. Simpul-simpul intermediate dari $p^{(1)}$ dan $p^{(2)}$ adalah dari $R’ = {1, 2, ..., k-1}$.
        \end{enumerate}

        Ketika $k$ bernilai 0, tidak ada simpul \textit{intermediate} pada $p$. Dari observasi di atas, dapat dibuat relasi rekurens untuk menghitung jalur terpendek dari $p$, yaitu
        \begin{equation}
            d_{i,j}^{(k)} =
            \begin{cases}
                d_{i,j}^{(0)}, & \text{if } k = 0\\
                min(d_{i,j}^{(k)}, d_{i,k}^{(k-1)} + d_{k,j}^{(k-1)}), & \text{otherwise}.
            \end{cases}
        \end{equation}
        dimana $d_{i,j}^{(n)}$ adalah panjang dari jalur terpendek dari i ke j. Dari relasi rekurens diatas, dapat dibuat pseudocode dari algoritma Floyd-Warshall sebagai berikut.

        \medskip
        \lstinputlisting[style=customc, mathescape=true]{codes/floyd-warshall.txt}

        Kompleksitas waktu dari algoritma Floyd-Warshall adalah $O(V^{3})$.
